# Point pattern analysis -- univariate methods for imaging-based data

In this vignette we will show:

- Univariate point pattern data analysis methods for imaging-based approaches.

- This includes global metrics on the entire field of view and local variants thereof. 

- The use case is a MERFISH data set from @moffittMolecularSpatialFunctional2018.

- For more background on point pattern analysis we refer the reader to @baddeleySpatialPointPatterns2015. 

- For the implementations we use `R`. Data is represented as `r BiocStyle::Biocpkg('SpatialExperiment')` [@righelliSpatialExperimentInfrastructureSpatiallyresolved2022].

# categorical Marks

{{< include theory/01-theory-point.qmd >}}

## Univariate viewpoint

In the following document we will often compare the distribution of mature oligodendrocytes (OD mature cells) across different $z$-slices of the same tissue. We assume these slices to be enough apart to be considered as generated by different point processes. Since we consider the dependence of one mark among itself, we are in a within cell type setting per slice. We compare several curves along different $z$-slices, which is in turn a multivariate comparison [@baddeleySpatialPointPatterns2015, pp. 564 ff.].

In our example dataset we analyse the mouse preoptic hypothalamus [@moffittMolecularSpatialFunctional2018]. The lower boundary is the border of the tissue whereas the other three boundaries are technical. Therefore, our example is a mixture between window sampling and the small world model. In order to decrease the bias of the tissue border, we use the Ripley-Rasson estimate of a spatial domain to estimate the sampling window [@baddeleySpatialPointPatterns2015, pp. 55; @ripleyFindingEdgePoisson1977].

```{r, fig.width=12, fig.height=6, cache=FALSE, message= FALSE, include = FALSE, eval = FALSE}
par(mfrow=c(1,3))
#Plot the marks separately 
lapply(zstack_list, function(zstack){
  plot(pp_ls[[zstack]][[celltype_ls]], main = zstack, legend = FALSE)
})
dev.off()

pls <- lapply(zstack_list, function(zstack){
  pp_sel <- pp_ls[[zstack]][[celltype_ls]]
  p <- pp_sel |> as.data.frame() |> 
  ggplot(aes(x = x, y = y, alpha = 0.3)) +
  geom_point(size=0.75) +
  theme_minimal() +
  coord_fixed() +
  ggtitle(zstack)
  return(p)
})
wrap_plots(pls, guides = 'collect')
```

## Correlation

Correlation, or more generally covariance, represents a second-order summary statistic and measures dependence between data points [@baddeleySpatialPointPatterns2015, pp. 199 ff.].

### Ripley's $K$

#### Empirical Ripley's $K$

With Ripley's $K$ we measure "the average number of $r$-neighbours of a typical random point" [@baddeleySpatialPointPatterns2015, pp. 204]. This number is still dependent on the size of the observation window so we can normalise it by the number of points $n$ and the window size, $|W|$. We then obtain the empirical Ripley's $K$ function [@baddeleySpatialPointPatterns2015, pp. 204; @ripleyModellingSpatialPatterns1977; @ripleySecondOrderAnalysisStationary1976]:

$$
\hat{K}(r) = \frac{|W|}{n(n-1)}\sum_{i=1}^n\sum_{j=1 \\j \neq i}^n\{d_{ij}\leq r\} e_{ij}(r)
$$

The standardisation makes it possible to compare point patterns with different observation windows and with different numbers of points. However, using the empirical $K$ function assumes that the point process has homogeneous intensity, which is often not the case for biological tissue [@baddeleySpatialPointPatterns2015, pp. 204-205]. We will return to this issue below in the `Correcting for Inhomogeneity`. The factor $e_{ij}(r)$ is an edge correction. We will briefly cover this in the following section.

#### Edge effects and their corrections for spatial metrics

Edge effects describe the phenomenon that not the entire point process is observed, but rather only the part within the window $W$. This means the value of various statistics could be biased along the edges [@baddeleySpatialPointPatterns2015, pp. 213 ff.].

There are many corrections for edge effects that are briefly listed here [@baddeleySpatialPointPatterns2015, pp. 214-219]:

##### Border correction

In border correction the summation of data points is restricted to $x_i$ for which $b(x_i,r)$ is completely in the window $W$.

##### Isotropic correction

We can regard edge effect as a sampling bias. Larger distances (e.g. close to the edges) are less likely to be observed. This can be corrected for.

##### Translation correction

A stationary point process $X$ is invariant to translations. So the entire point process can be shifted by a vector $s$ to be at the position $X+s$.

### The $L$-function

The $K$-function can be ''centered'', which is then referred to as Besag's $L$-function. The $L$-function is a variance-stabilising version of the $K$-function [@caneteSpicyRSpatialAnalysis2022; @besag1977contribution]:

$$
L(r) = \sqrt{\frac{K(r)}{\pi}}.
$$

By taking the square root the variance is approximately constant across the domain [@bartlettUseTransformations1947].

### Pair Correlation function

We have seen above that the $K$-function is cumulative. That is, the contributions of all distances smaller equal to $r$ are considered. An alternative is to take the derivative of the $K$-function in order to obtain contributions of distances between points equal to $r$, according to:

$$
g(r) = \frac{K'(r)}{2\pi r},
$$

where the derivative of the $K$ function divided by the probability of a Poisson process at this radius [@baddeleySpatialPointPatterns2015, pp. 225 ff.].

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide', include=TRUE}
#| message: false
#| warning: false
library('spatialFDA')

res_ls <- lapply(list('Kest', 'Lest', 'pcf'), function(fun) {
  res <- calcMetricPerFov(
    spe,
    'OD Mature',
    subsetby = 'sample_id',
    fun = fun,
    marks = 'cluster_id',
    rSeq = NULL,
    by = c('Animal_ID', 'sample_id')
  )
  res <- subset(res, sample_id %in% c('-0.09', '0.01', '0.21'))
  return(res)
})

p_ls <- lapply(res_ls, function(res) {
  plotMetricPerFov(
    res,
    theo = TRUE,
    correction = "iso",
    x = "r",
    imageId = 'sample_id',
    legend.position = "right"
  )
})
```

\

```{r, cache=FALSE, fig.height = 6, fig.width = 16, include=TRUE}
p_homo <- wrap_plots(p_ls, guides = 'collect')
p_homo
```

The plot above shows the $K$-function (right), $L$-function (middle) and pair-correlation function for the three different slices.

In the homogeneous case we see that all slices are above the Poisson line, indicating positive association for all slices. The association is strongest for slice $-0.09$ followed by $0.01$ and $0.21$. Interestingly, at radii $r>300µm$ the $K$ curve for slice $0.21$ crosses the other two curves.

### Correcting for Inhomogeneity

#### Inhomogeneous $K$-function

In the case that a spatial pattern is known or suspected to be inhomogeneous, we have to take this into account in the analysis. Inhomogeneous alternatives can be estimated via:

$$
\hat{K}_{inhom}(r) = \frac{1}{D^p|W|}\sum_i\sum_{j \neq i} \frac{\mathbb{1}\{||u-x_j||\leq r\}}{\hat{\lambda}(x_j)\hat{\lambda}(x_i)}e(x_j,x_i;r),
$$

where $e(u,v;r)$ is an edge correction weight and $\hat{\lambda}(x_i)$ is an estimator of the intensity at point $x_i$. The estimation of the local intensities can happen in a data-dependent manner via kernel-smoothing. As this is the same data to then calculate the metric on, this can lead to biases. However, if the local intensities are known, the inhomogeneous $K$ function is an unbiased estimator [@baddeleySpatialPointPatterns2015, pp. 242-246].

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
res_ls <- lapply(list('Kinhom', 'Linhom', 'pcfinhom'), function(fun) {
  res <- calcMetricPerFov(
    spe,
    'OD Mature',
    subsetby = 'sample_id',
    fun = fun,
    marks = 'cluster_id',
    rSeq = NULL,
    by = c('Animal_ID', 'sample_id'),
    correction = 'isotropic'
  )
  res <- subset(res, sample_id %in% c('-0.09', '0.01', '0.21'))
  return(res)
})

p_ls <- lapply(res_ls, function(res) {
  plotMetricPerFov(
    res,
    correction = "iso",
    theo = TRUE,
    x = "r",
    imageId = 'sample_id',
    legend.position = "right"
  )
})
```

```{r, cache=FALSE, fig.height = 6, fig.width = 16}
p_inhomo <- wrap_plots(p_ls, guides = 'collect')
p_inhomo
```

The inhomogeneous $K$-function indicates that the oligodendrocytes of slice $0.21$ are close to a Poisson process (dashed line) and can therefore be assumed to be randomly distributed and not clustered. The two other slices show a slightly stronger association among the oligodendrocytes than the slice $0.21$ at $r<250 µm$.

The $L$ function is complementary to the $K$ function in this example.

The pair correlation function is the derivative of the $K$-function. The pcf plot gives similar information as before: Oligodendrocytes show the strongest association at $\sim r = 25$ whereas the association is weaker in slice 0.21.

Interestingly, the curves for the inhomogeneous functions of slices $-0.09$ and $0.01$ cross the Poisson line at $r\sim250$. This means that the inhomogeneous functions find repulsion of slices past a radius of $250$.

### Local Scaling

#### Locally-scaled $K$-function

In the inhomogeneous $K$-function approach above, we assume that the intensities can vary locally but the scale of the point process is not changed. This means that while the intensities might vary in the parts of the point pattern, the pattern in one subquadrat is not just a scaled version of another subquadrat [@baddeleySpatialPointPatterns2015 pp. 246-247; @prokesovaStatisticsLocallyScaled2006].

To account for this local scaling, we can assume that the process is subdivided into small regions. In these small regions, the point process is a scaled version of a template process. This template process needs to be both stationary and isotropic [@baddeleySpatialPointPatterns2015 pp. 246-247].

#### Locally-scaled $L$-function

Since the $L$-function is simply a transformation of the $K$-function, the same local scaling framework can be applied to the $L$-function [@baddeleySpatialPointPatterns2015 pp. 246-247].

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide', include=TRUE}
res_ls <- lapply(list('Kscaled', 'Lscaled'), function(fun) {
  res <- calcMetricPerFov(
    spe,
    'OD Mature',
    subsetby = 'sample_id',
    fun = fun,
    marks = 'cluster_id',
    rSeq = NULL,
    by = c('Animal_ID', 'sample_id')
  )
  res <- subset(res, sample_id %in% c('-0.09', '0.01', '0.21'))
  return(res)
})

p_ls <- lapply(res_ls, function(res) {
  plotMetricPerFov(
    res,
    correction = "iso",
    theo = TRUE,
    x = "r",
    imageId = 'sample_id',
    legend.position = "right"
  )
})
```

```{r, cache=FALSE, fig.height = 6, fig.width = 16, include=TRUE}
p_scaled <- wrap_plots(p_ls, guides = 'collect')
p_scaled
```

We see, that in slice 0.01 oligodendrocytes are far from the Poisson process line, indicating a strong association. The other two slices show a less strong association.

```{r, cache=FALSE, fig.height = 10, fig.width = 16, include=TRUE}
p <- wrap_plots(list(p_homo, p_inhomo, p_scaled),
                nrow = 3,
                guides = 'collect') + plot_annotation(tag_levels = 'A')
p
```

In the plot above we see all variants of the correlation metrics. The assumptions of either homogeneity (first row), inhomogeneity (second row) and local scaling (third row) change the interpretation of these example point patterns. In summary, in this example homogeneous variants show a positive association for all slices. Furthermore, homogeneous variants estimated clustering for all radii, whereas clustering in slice $0.21$ became stronger than in the other two slices past $r>250$. Inhomogeneity inferred a Poisson distribution for slice $0.21$. In addition, the inhomogeneous variant estimated repulsion for slices $-0.09$ and $0.01$. The locally scaled version showed positive associations for all slices and no crossing of curves over the radii.

Deciding whether a pattern is homogeneous or inhomogeneous can be based on metrics as seen above. However, as the result of these metrics depend on the parameter choice (e.g., size of quadrants), the biological question can also be used to decide whether a pattern is assumed to be homogeneous or inhomogeneous. We provide some recommendations in the "Overview" vignettes.

#### Local Indicators of Spatial Association

It is worth noting that the $K$- and $L$-functions described above are summary statistics over the entire pattern (i.e., averaged over all points). However, if we know that there are different regions in our point pattern, an alternative strategy is to compute ''local'' contributions to these patterns, i.e., local $K$- ,$L$- or pair-correlation functions [@anselinLocalIndicatorsSpatial1995]. @baddeleySpatialPointPatterns2015 propose to compare these $n$ functions with so-called functional principal component analysis (see below). We will show here the example of the LISA version of the $L$-function [@baddeleySpatialPointPatterns2015 pp. 247-248].

##### Local $L$ function

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
L_odmature_lisa <- localL(pp_ls[['0.01']]$`OD Mature`)

df <- as.data.frame(L_odmature_lisa)
dfm <- reshape2::melt(df, "r")

get_sel <- dfm %>% filter(r > 200.5630 &
                            r < 201.4388, variable != "theo") %>%
  mutate(sel = value) %>% select(variable, sel)

dfm <- dfm %>% left_join(get_sel)

p <- ggplot(dfm, aes(
  x = r,
  y = value,
  group = variable,
  colour = sel
)) +
  geom_line() +
  scale_color_continuous(type = "viridis") +
  geom_vline(xintercept = 200) +
  theme(legend.position = "none") +
  theme_light() +
  ggtitle("LISA curves of slice 0.01")

ppdf <- as.data.frame(pp[['0.01']]) %>% filter(marks == "OD Mature")
ppdf$sel <- get_sel$sel # assume they are in same order

q <- ggplot(ppdf, aes(x = x, y = y, colour = sel)) +
  geom_point(size = 0.75) +
  scale_color_continuous(type = "viridis") +
  theme(legend.position = "none") +
  theme_light() +
  ggtitle("Points coloured by LISA value at r ~ 200")
```

```{r, fig.height=5, fig.width=10}
p|q
```

In the case of the OD mature cells, we obtain further information with this plot. We note that there are two distinct populations of curves: those that are clearly above the mean LISA curve in grey and others that are around/underneath. This indicates that there are two different kinds of interactions in the OD mature cells. Stronger and less clustered regions.

There are inhomogeneous versions of these (e.g. `localLinhom`) that are not shown here for brevity.

##### Functional PCA for the $n$ Curves

We apply functional PCA to retrieve the main trends in these individual curves. The idea of functional PCA is the same as for ordinary PCA but applied to functional data (i.e., each observation is a function). For the $n$ functions above, functional PCA will recover the main trends in the data [@ramsayPrincipalComponentsAnalysis2005]. We use the `R` package `refund` to perform functional PCA [@goldsmithRefundRegressionFunctional2024; @xiaoFastCovarianceEstimation2016].

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
#normalise the data
df_fdob <- asinh(df %>% as.matrix / 50) %>% as.data.frame()
# extract the functional response matrix
mat <- df_fdob %>%
  select(!c(r, theo)) %>%
  t()
# create a dataframe as required by pffr
dat <- data.frame(ID = rownames(mat))
dat$Y <- mat
dat$sel <- get_sel$sel

# perform functional PCA
res <- functionalPCA(
  dat = dat,
  r = df_fdob$r |> unique()
)
# extract the scores
scores_df <- res$scores %>% as.data.frame()
# plot a biplot
p_biplot <- ggplot(scores_df, aes(scores_df[, 1], scores_df[, 2], colour = (dat[['sel']]))) +
  geom_point() +
  coord_equal() +
  theme_light() +
  scale_color_continuous(type = "viridis") +
  xlab('PC1') +
  ylab('PC2')
```

```{r, fig.height=5, fig.width=10}
p_biplot
```

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
p1 <- ggplot(ppdf, aes(
  x = x,
  y = y,
  colour = res$scores[, 1]
)) +
  scale_color_continuous(type = "viridis", name = 'loading PC1') +
  theme_light() +
  geom_point(size = 0.75)

p2 <- ggplot(ppdf, aes(
  x = x,
  y = y,
  colour = res$scores[, 2]
)) +
  scale_color_continuous(type = "viridis", name = 'loading PC2') +
  theme_light() +
  geom_point(size = 0.75)
```

```{r, fig.height=5, fig.width=10}
p1|p2
```

The biplot shows the distribution of the first two loadings of the functional PCA. The points are coloured as they were in the plots of the LISA $L$-curves. The first principal component clearly separates the two populations. In the last plot we project the loadings of the fPCs back onto the biological slices and find the same separation.

### Third-Order Summary Statistics

So far we have considered first- and second-order summary statistics and local (or inhomogeneous) adaptations of them. In the second order, one considers (counts of) pairs (e.g., $K$ function). In a third-order setting, we would count triplets of points. A triplet is counted as the normalised expected value of triangles where all edges are smaller than the radius $r$ [@baddeleySpatialPointPatterns2015 pp. 249].

````{=html}
<!--
$$
T(r) = \frac{1}{\lambda^3}\mathbb{E}\left[\sum_{i=1}^n\sum_{j=1\\j\neq i}^nm(x_i,x_j,u) | u \in X\right]
$$

here m is the maximum side of the triangle

$$
m(a,b,c) = \max(||a-b||,||a-c||,||b-c||)
$$
```{r, include=FALSE, eval=FALSE}
p <- plotMetric(zstack_list, pp_ls, celltype_ls, 'r', 'Tstat', 'border', bootstrap = FALSE)
p
```

[MR: should we skip the plot in this section?]
-->
````

## Spacing

So far, most approaches considered intensity and correlation as measures to assess a point pattern. Next, we will look at measures of spacing and shortest-distances to assess spatial arrangements [@baddeleySpatialPointPatterns2015 pp. 255].

Baddeley et al. summarises three basic distances:

-   pairwise distance: $d_{i,j} = ||x_i-x_j||$
-   NN distances: $d_i = \min_{j \neq i}d_{ij}$
-   empty-space distance: $d(u) = \min_j||u-x_j||$

Note also that there are tests of CSR that are based on spacing, including the Clark-Evans and Hopkins-Skellam Index tests that were discussed above ''Testing for CSR''.

### Nearest-neighbour approaches

Nearest-neighbour (NN) methods are based on the notion of "nearness". In particular, we introduce `nndist` from `r BiocStyle::CRANpkg('spatstat')`, a method to calculate the distances until $k$ NN are found. This function returns a density for each specified $k$ for the $k$ neighbour distances. We can for instance collapse the $k$ curves into a mean curve per point pattern. This information of the mean nearest neighbour distance (MMND) can be summarised as a density. Note, that these distances are "raw" nearest-neighbour distances which are not corrected for edge effects. Edge correction for the nearest neighbour distance ($k = 1$) is implemented in the function `Gest`, see next paragraph [@baddeleySpatialPointPatterns2015 pp. 256; @baddeleySpatstatPackageAnalyzing2005].

```{r, cache=FALSE}
nndistance <- function(pp, nk) {
  xy <- cbind(pp$x, pp$y)
  nndistances_k15 <- nndist(xy, k = nk)
  nndistances_mean <- rowMeans(nndistances_k15)
  return(nndistances_mean)
}

#PRE: list of point pattern, corresponding celltypes of interest, functions to evaluate
#POST: result of the metric
metricRes_nndist <- function(ppls, celltype, fun) {
  metric.res <- list(res = do.call(fun,
                                   args = list(pp = ppls[[celltype]],
                                               nk = seq(1:15))))
  metric.res$type = celltype
  return(metric.res)
}

celltypes <- c("Ependymal", "OD Mature", "Microglia")
#go through all defined celltypes and calculate the nearest-neighbour distance
res_ls <- lapply(celltypes, metricRes_nndist, fun = nndistance, ppls = pp_ls[['0.01']])
#initialise a dataframe for the metric values and the type information
res_df <- data.frame(metric = numeric(0), type = character(0))
# Loop through the res_ls list and combine the metric values with their corresponding type
for (i in 1:length(res_ls)) {
  metric_values <- res_ls[[i]]$res
  metric_type <- rep(res_ls[[i]]$type, length(metric_values))
  df <- data.frame(metric = metric_values, type = metric_type)
  res_df <- rbind(res_df, df)
}
#plot the densities
p <- ggplot(res_df, aes(x = metric, col = type)) +
  geom_density(linewidth = 1) +
  scale_x_sqrt() +
  theme_light() +
  ggtitle('Sqrt of the Mean Nearest-Neighbour Distance')
p
```

In the MNND empirical distribution, the ependymal cells show the shortest NN distances, a reflection of their clustering. The OD mature cells have larger NN distances as well as a bimodal distribution, indicating a mix of shorter and longer distances (as visible in the LISA $L$-functions). Microglia cells show the widest distances and the symmetry of the curve indicates similar distances throughout the field of view.

### Nearest-neighbour function $G$ and empty-space function $F$

#### Definitions of $F$ and $G$ function

In a stationary spatial point process, the empty-space distance is defined as:

$$
d(u,X) = \min\{||u-x_i||: x_i \in X\}
$$

Note that this is an edge-corrected distribution function of the nearest-neighbour distance above.

The empty space function is then the cumulative distribution function of the empty-space distances defined above:

$$
F(r) = \mathbb{P}\{d(u,X)\leq r\}.
$$

The NN distance is defined as:

$$
d_i = \min_{j\neq i}||x_j-x_i||.
$$

The NN distance distribution function $G(r)$ is then defined as:

$$
G(r) = \mathbb{P}\{d(x,X\backslash u \leq r |X\ has\ a\ point\ at\ u\}.
$$

For a homogeneous Poisson process, the NN distance distribution is identical to the empty-space function of the same process:

$$
G_{pois} \equiv F_{pois}.
$$

For a general point process, the $F$ and $G$ functions are different [@baddeleySpatialPointPatterns2015 pp. 261-267].

### Empty-space hazard

The $F$ and $G$ functions are, like the $K$ function, cumulative. Therefore, an analogue to the pair-correlation function would make sense to consider. For practical reasons, this is no longer the derivative of the $F$ function but rather a hazard rate:

$$
h(r) = \frac{f(r)}{1-F(r)}.
$$

[@baddeleySpatialPointPatterns2015 pp. 271-274].

### $J$-Function

The concepts of the empty-space function $F$ and the NN function $G$ are complementary. If one decreases, the other increases.

Thus, the $J$ function is a combination of both functions:

$$
J(r) = \frac{1-G(r)}{1-F(r)}.
$$

For a CSR process, $J_{pois} \equiv 1$, whereas values of $J(r) > 1$ are consistent with a regular (e.g., repelling) pattern, and $J(r) < 1$ represents a clustered process [@baddeleySpatialPointPatterns2015 pp. 275-277].

```{r, fig.height = 10, fig.width = 7}
res_ls <- lapply(list('Gest', 'Fest', 'Jest'), function(fun) {
  res <- calcMetricPerFov(
    spe,
    'OD Mature',
    subsetby = 'sample_id',
    fun = fun,
    marks = 'cluster_id',
    rSeq = NULL,
    by = c('Animal_ID', 'sample_id')
  )
  res <- subset(res, sample_id %in% c('-0.09', '0.01', '0.21'))
  return(res)
})

p_ls <- lapply(res_ls, function(res) {
  plotMetricPerFov(
    res,
    correction = "rs",
    theo = TRUE,
    x = "r",
    imageId = 'sample_id',
    legend.position = "right"
  )
})
```

```{r, cache=FALSE, fig.height = 6, fig.width = 16}
wrap_plots(p_ls, guides = 'collect')
```

### Accounting for Inhomogeneity in Spacing Functions

There are inhomogeneous variants of the spacing functions explained above [@baddeleySpatialPointPatterns2015 pp. 277-278]

```{r}
res_ls <- lapply(list('Ginhom', 'Finhom', 'Jinhom'), function(fun) {
  res <- calcMetricPerFov(
    spe,
    'OD Mature',
    subsetby = 'sample_id',
    fun = fun,
    marks = 'cluster_id',
    rSeq = NULL,
    by = c('Animal_ID', 'sample_id')
  )
  res <- subset(res, sample_id %in% c('-0.09', '0.01', '0.21'))
  return(res)
})

p_ls <- lapply(res_ls, function(res) {
  plotMetricPerFov(
    res,
    correction = "bord",
    theo = TRUE,
    x = "r",
    imageId = 'sample_id',
    legend.position = "right"
  )
})
```

```{r, cache=FALSE, fig.height = 6, fig.width = 16}
wrap_plots(p_ls, guides = 'collect')
```

The inhomogeneous curves look different to their homogeneous counterparts but the relative ordering of the curves per plot is the same.

### Nearest-Neighbour Orientation

Next to the NN distance, we can estimate the *orientation* of the neighbours, which gives an indication of the orientation of the spacing. It works by taking the angle between each point and its $k^{th}$ nearest neighbour. The angle is anticlockwise from the x-axis [@baddeleySpatialPointPatterns2015 pp. 278-279] [@baddeleySpatstatPackageAnalyzing2005].

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide', include=TRUE}
res <- calcMetricPerFov(
  spe,
  'OD Mature',
  subsetby = 'sample_id',
  fun = 'nnorient',
  marks = 'cluster_id',
  rSeq = NULL,
  by = c('Animal_ID', 'sample_id')
)
res <- subset(res, sample_id %in% c('-0.09', '0.01', '0.21'))
p <- plotMetricPerFov(
  res,
  correction = "bordm",
  theo = TRUE,
  x = "phi",
  imageId = 'sample_id',
  legend.position = "right"
)
```

```{r}
p
```

The values of $\phi$ correspond to the orientation of the original point pattern. The horizontal axis goes from $180$ to $0$ (left to right) and the vertical from $90$ to $270$ (top to bottom)

an easier representation of the above metric can be plotted as a rose diagram

```{r, message=FALSE, warning=FALSE, fig.width=6, fig.height=6}
lapply(seq_along(pp), function(x){rose(nnorient(pp[[x]]), main = names(pp)[x])})
```

The two plots are complementary and show which are the preferred orientations of the point patterns. Furthermore, they show whether or not the assumption of isotropy (no change in the statistical properties of a point pattern after rotations) is justified or not [@baddeleySpatialPointPatterns2015 pp. 236 ff.]. Isotropy is an assumption that a lot of spatial metrics make and in our example we note, that the point patterns are in fact anisotropic as we can see a trend for the preferred orientation in the rose diagrams. An option for analysing anisotropic stationary point patterns is to not calculate the metric on the actual point pattern but rather calculating it on the fry plot of the point pattern. This generalises e.g. Ripley's $K$ function from circles to arbitrary shapes [@baddeleySpatialPointPatterns2015 pp. 239 ff.].

Note also that the concepts of spacing are not only usable in *point* pattern analysis but also more broadly in other spatial contexts (e.g., spacing between shapes instead of points) [@baddeleySpatialPointPatterns2015 pp. 279 ff.].

### Edge Corrections

The same consideration about edge effects as for the $K$ (and related) functions need to be made for the spacing functions; uncorrected estimates are negatively biased estimators. The easiest approach is to draw an artificial border and consider NNs within it. Other approaches are based on sampling. Yet another approach relates to survival analysis, with the idea is that a circle of a point to grows homogeneously with increasing radius until it hits the frame of the window and "dies". This gives survival distributions similar to censored data, where the Kaplan-Meier estimator is a good choice [@baddeleySpatialPointPatterns2015 pp. 285-292].

# Continuous Marks

## Setup

```{r, message=FALSE}
#| label: load-data 2
# redefine the pp here to be zstack 0.01
pp <- pp[['0.01']]
sub <- spe[, spe$sample_id == '0.01']
```

In `r BiocStyle::CRANpkg('spatstat')`, a `mark` can basically take any value, categorical (e.g. cell types, as we have seen above) or continuous (e.g., gene expression) [@baddeleySpatialPointPatterns2015 pp. 637 ff.]. In our example, we take the gene expression of some marker genes from Fig. 6 of the original publication [@moffittMolecularSpatialFunctional2018]. This is a typical numerical mark for points in a biological dataset. Here, we will use all cell types for the analysis of numerical marks.

```{r}
#  Genes from Fig. 6 of Moffitt et al. (2018)
genes <- c('Slc18a2', 'Esr1', 'Pgr')
gex <- assay(sub)[genes,] %>% t %>% as.matrix %>% 
  data.frame %>% set_rownames(NULL)

marks(pp) <- gex
```

```{r, fig.width = 10, fig.height=6}
# create a dataframe in long format for plotting
pp_df <- pp |>
  as.data.frame() |>
  tidyr::pivot_longer(cols = 3:5)

ggplot(pp_df, aes(x, y, colour = log(value + 1))) +
  geom_point(size = 0.5) +
  facet_wrap(~name) +
  coord_equal() +
  scale_color_continuous(type = "viridis") + 
  theme_light()
```

Here we see spatial distribution of the counts of the three genes *Slc18a2*, *Esr1* and *Pgr*.

The function `pairs` from `r BiocStyle::CRANpkg('spatstat')` generates a scatterplot of the counts of the marks (in our case the three genes) against each other and against the $x$ and $y$ coordinates. We can add a non-linear smoothing curve to make the general trends a bit more obvious [@baddeleySpatialPointPatterns2015 pp.641].

```{r, fig.width=8, fig.height=8}
pairs(as.data.frame(pp), panel = panel.smooth, pch=".")
```

We find that the counts of the three genes are very evenly distributed along the $x$ and $y$ coordinate, indicating a homogeneous distribution. The counts of *Esr1* and *Pgr* are positively associated, indicating a dependence of these two marks.

NN interpolations uses the nearest mark to measure the intensity at each spatial location. This is conceptually similar to taking a very small bandwidth for Gaussian kernel smoothing [@baddeleySpatialPointPatterns2015 pp. 642].

```{r, fig.width=8, fig.height=8}
plot(nnmark(pp))
```

We see that there is e.g. a clear spatial structure in the expression of e.g. *Esr1*. It shows a half moon shape.

## Summary functions for continuous marks

As in the discrete case, summary functions assume that the point process is stationary.

### Mark correlation function

The mark correlation function measures the dependence between two marks for two points at distance $r$. It is applicable to stationary point processes with marks. The generalized mark correlation function is given by:

$$ k_f(r) = \frac{\mathbb{E}[f(m(u),m(v)) \mid \| u - v \| = r]}{\mathbb{E}[f(M,M')]},$$

where $f(m(u),m(v))$ is a test function with two arguments (representing the two marks at locations $u$ and $v$ with distance $r$ apart) and returns a non-negative value. For continuous non-negative marks, the canonical choice for $f$ is typically $f(m(u),m(v))= m(u)m(v)$. $M$ and $M′$ represent independent, identically distributed random points with the same distribution as the mark of a randomly chosen point. This denominator is chosen such that random marks have a mark correlation of 1 [@baddeleySpatialPointPatterns2015 pp. 644-645].



```{r}
res <- calcMetricPerFov(
  sub,
  'OD Mature',
  subsetby = genes,
  fun = 'markcorr',
  marks = genes,
  rSeq = NULL,
  by = c('Animal_ID', 'sample_id'),
  continuous = TRUE
)
p <- plotMetricPerFov(
  res,
  correction = "iso",
  theo = TRUE,
  x = "r",
  imageId = 'gene',
  legend.position = "right"
)
p
```

From this plot we show that all genes show a positive correlation at small distances which decline with increasing radius $r$. The association is strongest for the *Slc18a2* gene. We can calculate simulation envelopes to estimate the significance of this association. This is not shown for brevity.

### Mark-weighted $K$-function

The mark-weigthed $K$-function is a generalization of the $K$-function in which the contribution from each pair of points is weighted by a function of their respective marks. It is given by:

$$K_f(r) = \frac 1  \lambda \frac{C_f(r)}{E[ f(M_1, M_2) ]},$$ where

$$ C_f(r) = E \left[ \sum_{x_j \in X} f(m(u), m(x_j)) \mathbf{1} \{0 < ||u - x_j|| \le r\} \;  \mid \; u \in X \right], $$

is equivalent to the unnormalized mark-weighted $K$-function. For every point $u$, we sum the euclidean distance $||u - x||$ of all other points $x$ that are within a distance $r$. This sum is weighted by the function $f(.,.)$ of the marks of $u$ and $x$. The function is standardized by the expected value of $f(M_1, M_2)$ where $M_1, M_2$ represent independent, identically distributed random points with the same distribution as the mark of a randomly chosen point [@baddeleySpatialPointPatterns2015 pp. 646-647].

In the scenario of random labeling, so where the marks are distributed randomly, the mark-weighted $K$-function corresponds to the standard Ripley's $K$-function.

Also here, the canonical function is: $f(m_1, m_2) = m_1 m_2$. This means we weigh each interaction between points by the product of the continuous marks of both points.

```{r}
res <- calcMetricPerFov(
  sub,
  'OD Mature',
  subsetby = genes,
  fun = 'Kmark',
  marks = genes,
  rSeq = NULL,
  by = c('Animal_ID', 'sample_id'),
  continuous = TRUE
)
p <- plotMetricPerFov(
  res,
  correction = "iso",
  theo = TRUE,
  x = "r",
  imageId = 'gene',
  legend.position = "right"
)
p
```

It is important to note that the theoretical value of the $K$-function is not very informative since it represents the $K$-function of a Poisson point process and the underlying point process might not be Poisson. Therefore we compare the mark-weighted with its unmarked analogue. Like this, we can assess whether the points weighted by a continuous mark are more or less correlated than their unmarked analogues [@baddeleySpatialPointPatterns2015 pp. 647].

Here we will compare the $L$-functions weighted by the mark of the gene *Esr1* and the unmarked $L$-function.

```{r}
ppEsr1 <- subset(pp, select = 'Esr1')
L.Esr1L <- Kmark(ppEsr1, function(m1,m2) {m1*m2}, returnL = TRUE)
Lest.ppEsr1 <- Lest(ppEsr1, nlarge=7000)
plot(eval.fv(L.Esr1L - Lest.ppEsr1))
```

We note that the difference between $L$-function weighted by the expression of *Esr1* minus the unmarked $L$-function is positively different to the Poisson difference, meaning that the expression of the continuous mark *Esr1* is correlated among itself.

# Summary

In this chapter we have looked at point pattern methods that can be applied to univariate marks. These univariate marks can either be categorical (in a molecular biological context that could be celltypes) or continuous (e.g. expression of a gene). There are approaches that summarise correlative dependencies among points or that consider spacing functions.

# Appendix

## Session info

```{r, cache=FALSE}
#| label: session-info
sessionInfo()
```
